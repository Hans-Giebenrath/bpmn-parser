= Text Format (DSL) Overview

If you are not super familiar with BPMN, I recommend you to refer to the
link:https://camunda.com/bpmn/reference/[BPMN Reference] provided by Camunda.

BPMN diagrams might be easy in the beginning - just non-decorated tasks and events. To support this
quicker phase in the beginning, there is a shorthand syntax for the common diagram elements. These
are shown first. The shorthand syntax and full syntax can be mixed freely at will, but for a more uniform
visual appearance I recommend to eventually convert everything to the full syntax when a diagram
makes more use of it.

== Events and Activities - Shorthand Syntax

Let's look as this tiny example:

image::generated/overview-tiny.png[]

[,bpmd]
----
include::example$overview-tiny.bpmd[]
----

One line usually corresponds to one statement. We have here in total four statements.
A statement begins with the type identifier (`#`, `-`, `.`), and then there are a bunch of further attributes.
Here we only have the display text attribute, which is mostly arbitrary free-form text.

In BPMN the most common thing you want to do is connect events and tasks via sequence flows. This is
reflected by the file: You just list line-by-line events and tasks, and they are automatically
connected by sequence flows.

A business process begins usually with some event (although there are exceptions).
Events are typed with the `#` sigil, hence the first line in the simple example is the following:

[,bpmd]
----
# Start
----

As you noticed, the `# Start` and `# Intermediate Event` have different visuals - `bpmd`
automatically chooses the correct symbol, you don't have to think about it. The only exception is
the end of a process which has a dedicated sigil:

[,bpmd]
----
. End
----

During testing it looked more readable to have a dedicated sigil for ending a process, instead of
repurposing `#`.

Feel free to compile the argument with the start event or end event removed. If you feel the error
messages are lacking, then link:github.com/Hans-Giebenrath/bpmn-parser/issues[open an issue] with a
constructive suggestion.

== Gateways - Shorthand Syntax

image::generated/overview-gateway.png[]

[,bpmd]
----
include::example$overview-gateway.bpmd[]
----
<1> The node label `Gateway` is not yet rendered.
<2> The edge label `Edge Text` is not yet rendered.

Gateways break up the natural sequence flow from line to line. Instead, a gateway finishes it and
sends the sequence flow elsewhere via `->one` and `->two` "jumps". The "landing" counterparts are `F
<-label` meta statements. These `F` statements don't correlate to a node in the resulting diagram,
they are purely for connecting loose ends of a detached sequence flow.

In principle, you can add a display text to an edge via `<-label"Display Text"` but the actual
rendering is still waiting on the roadmap.

As you see, labels don't need to be unique. The `end` label is reused, and this is possible as well
with on the branching gateway node:

image::generated/overview-gateway2.png[]

[,bpmd]
----
include::example$overview-gateway2.bpmd[]
----

You might notice that the order of the nodes is not quite what is written in the file ("Three",
"One", "Two" instead of "One", "Two", "Three"). This is also on the roadmap to nudge this vertical
node order into the same order as they appeared in the file (if the order can be changed without
affecting the layout quality).

You might be tempted to check whether you can mix `+` with `X` gateway nodes. At the moment this
works perfectly fine, but a correctness analysis to prevent this is on the roadmap.

== Pools and Lanes

The examples above omitted pools and lanes to focus on the sequence flows and nodes. Here they are:

image::generated/overview-pool-lane.png[]

[,bpmd]
----
include::example$overview-pool-lane.bpmd[]
----
<1> You can still omit a dedicated lane if you want.

Pools are introduced via `= Display Text` and lanes via `== Display Text`. A pool can have any
number of lanes. While you saw that the order of gateway branches can change for layout quality
purposes, this is not done for lanes or pools. They always appear in the order as they are declared
in the text file.

Some diagrams place two shorter pools horizontally on the same line next to each other. This is
currently not supported but is on the roadmap.

== Sequence Flow across Lanes

You can reuse the `F` statement to transition from one lane to another lane.

image::generated/overview-lane-crossing.png[]

[,bpmd]
----
include::example$overview-lane-crossing.bpmd[]
----
<1> You can still omit a dedicated lane if you want.

IMPORTANT:: The syntax will likely get rid of `F` meta statements and just use `<-` and `->` on the task and
event statements. The dedicated statement does better highlight that there is a break in the
sequence flow, but it also adds quite a lot of length to the text file for otherwise small diagram.
To avoid situations where some people prefer one way and some people prefer the other way, only one
syntax will stay valid (think of the wasted hours when these differently opinionated people mix and
start bike-shedding). Maybe an empty newline will become mandatory to enforce clear visuals.

As you can see, `Lane 2` does not start with a start event. Instead it starts off with an incoming
sequence flow landing.

== Message Flows

Inter-pool communication is done via message flows. Those are added as dedicated statements:

[,bpmd]
----
`MF <-from ->to`.
----

image::generated/overview-message-flow.png[]

[,bpmd]
----
include::example$overview-message-flow.bpmd[]
----

A message flow statement is special in that it does not represent a node, but only a single arrow.
Hence it must have exactly one incoming arrow `<-from` which designates the source, and `->to` which
designates the target.

While with gateways you had to match the labels of the `X ->lbl` and `F <-lbl` statements, the `from` and `to`
labels can use _fuzzy matching_. That is, you can specify some shortened version of the source /
target node display text as
the label, and that shortened version then looks through all previously defined nodes for the best
match. As you can see, the pool display text (and actually also the lane display text, if it were
present), can be used as well in the label, whereas you should first specify the pool components (if
you want to use some), then the lane components (if you want to use some) and then the node
components. Sometimes it might be too tedious to think about a good fuzzy selector, or you are sure
that the display text will change in the future but you want stable references now. In that case you can
also make use of unique identifiers which are specified via the `@identifier` attribute as follows:

[,bpmd]
----
= Pool K

// ...
- Rest by the Tumtum Tree @abc
// ...

= Pool L

// ...
- Whiffle through the Tulgey Wood @def
// ...

MF <-abc ->def // Uses identifiers, not the display text
----

== Data Elements

Data elements use the statment type `OD` for data object and `SD` for data store. They use incoming
`<-label` and outgoing `->label` labels to connect data associations with activities.

image::generated/overview-data.png[]

[,bpmd]
----
include::example$overview-data.bpmd[]
----

Since the source and targets for the data associations are nodes, the same fuzzy matching algorithm
is used as is for message flows.

== Semantic Data Elements - Data Continuations

In the previous example the data object was used in activities that lay close together on the
layouted diagram. There can be situations where (1) the diagram becomes larger and you don't want to
have super long edges uglifying the diagram, (2) show that data goes through stages by giving it
different names, whereas it is still the very same data object, (3) send data across pools and show
that they are the same data object. For these situations, there is the data continuation syntax `&`
(with friends `O&` and `S&`) to create a new data icon in the layouted diagram, but communicate to
the reader (and to possible analysis extensions) that they are _actually_ the same piece of data.

image::generated/overview-data-continuations.png[]

[,bpmd]
----
include::example$overview-data-continuations.bpmd[]
----

In the given example you could argue whether the book that is now augmented with a signature is
actually a new object, but this is a question which very much depends on the use case. But you get
the idea of what you could do with the feature.

In the future it will be possible to change the icon type during the continuation, e.g. in a chain
of `OD .. S& .. D& ..`.

== Recommended Structure of a `.bpmd` File

Pools, lanes and their contained events and tasks are naturally grouped. For data elements and
message flows the recommendation is to keep data objects at the end of the pool or lane where they
are used, or after the last pool if they stretch across multiple pool.

For message flows it is recommended to keep them after the last pool after any data elements. This
way a reader knows where to look for what kind of statement, and they don't have to search through
the whole file.

Also be aware that node fuzzy matching only looks at nodes which have been defined _previously_. So
if the referenced node is only coming later, it cannot be found. Therefor, you cannot put data
objects or message flows at the very top, as then no events / tasks have been defined, yet.

== Boundary Events


